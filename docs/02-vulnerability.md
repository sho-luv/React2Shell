# Chapter 2: The Vulnerability

Now that you understand the fundamentals, let's examine how CVE-2025-55182 works.

---

## The Vulnerable Code

The vulnerability exists in `ReactFlightReplyServer.js`, specifically in the `getOutlinedModel` function.

### Simplified Vulnerable Code

```javascript
function getOutlinedModel(response, reference, parentObject, key, map) {
  // reference looks like: "$1:path:to:property"
  // Split into parts: ["1", "path", "to", "property"]
  const path = reference.split(':');
  const id = path[0];

  // Get the chunk object
  let value = response._chunks[id];

  // Traverse the path
  for (let i = 1; i < path.length; i++) {
    value = value[path[i]];  // ← THE BUG IS HERE
  }

  return value;
}
```

### What's Wrong?

The code traverses object properties using attacker-controlled path values **without checking if the property exists on the object itself**.

```javascript
value = value[path[i]];  // No validation!
```

If `path[i]` is `"__proto__"`, this accesses `value.__proto__`, which is `Object.prototype`.

---

## Understanding the Attack

### Step 1: Path Traversal to Prototype

An attacker sends a reference like:

```
$1:__proto__:then
```

This is parsed as:
- Chunk ID: `1`
- Path: `["__proto__", "then"]`

The code does:
```javascript
value = chunks[1];           // Get chunk 1
value = value["__proto__"];  // Now value = Object.prototype
value = value["then"];       // Access Object.prototype.then
```

### Step 2: Prototype Pollution

If the attacker can SET a value at this path, they pollute the prototype:

```javascript
Object.prototype.then = maliciousFunction;
```

### Step 3: Promise Hijacking

Here's the clever part. JavaScript Promises check if a value has a `.then` method:

```javascript
// Normal promise resolution
Promise.resolve(someValue).then(callback);

// If someValue.then exists, it's called!
```

By polluting `Object.prototype.then`, the attacker hijacks ALL promise resolutions.

---

## The Exploit Chain

Let's trace the complete attack:

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. Attacker sends malicious Flight payload                      │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 2. Server deserializes payload, processes references            │
│    Reference "$1:__proto__:then" traverses to Object.prototype │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 3. Object.prototype.then gets polluted with attacker's value    │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 4. Later, a Promise resolves and calls the polluted .then()     │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 5. Attacker's code executes with server privileges              │
└─────────────────────────────────────────────────────────────────┘
```

---

## From Pollution to Code Execution

Polluting `.then` isn't enough - we need to execute arbitrary code. Here's how:

### The Function Constructor

In JavaScript, `Function` is a constructor that creates functions from strings:

```javascript
const fn = new Function('return 1 + 1');
fn();  // Returns 2

const evil = new Function('return process.exit(1)');
evil();  // Kills the process!
```

### Accessing Function Constructor

Every function has a `.constructor` property pointing to `Function`:

```javascript
(function(){}).constructor === Function  // true

// You can also chain:
"".constructor.constructor === Function  // true
```

### The Attack

1. Pollute `Object.prototype.then` to point to `Function`
2. When a promise resolves, it calls `value.then()`
3. But `then` is now `Function`
4. `Function(attackerCode)()` executes the attacker's code

---

## The Fix

The patch adds a simple check:

```javascript
// BEFORE (vulnerable)
for (let i = 1; i < path.length; i++) {
  value = value[path[i]];
}

// AFTER (patched)
for (let i = 1; i < path.length; i++) {
  if (!Object.prototype.hasOwnProperty.call(value, path[i])) {
    // Property doesn't exist on the object itself
    // Don't traverse into the prototype chain
    return waitForReference(response, ...);
  }
  value = value[path[i]];
}
```

The fix ensures we only access properties that exist **directly on the object**, not inherited from the prototype.

---

## Why It's So Dangerous

| Factor | Impact |
|--------|--------|
| **No Authentication** | Anyone can send the malicious request |
| **Default Configs** | Fresh `create-next-app` installs are vulnerable |
| **Reliable** | Exploit works consistently, no race conditions |
| **Full RCE** | Complete server compromise |
| **Widespread** | Millions of Next.js sites potentially affected |

---

## Knowledge Check

1. **Why does accessing `obj["__proto__"]` reach the prototype?**
   <details>
   <summary>Answer</summary>
   The `__proto__` property is a special accessor that returns the object's prototype. When you access it, you get Object.prototype (for regular objects).
   </details>

2. **Why are Promises involved in this exploit?**
   <details>
   <summary>Answer</summary>
   Promises check if resolved values have a `.then` method and call it. By polluting Object.prototype.then, the attacker hijacks this mechanism to execute code.
   </details>

3. **How does the Function constructor enable RCE?**
   <details>
   <summary>Answer</summary>
   `new Function(code)` creates a function from a string. If an attacker controls that string, they can execute arbitrary JavaScript on the server.
   </details>

4. **Why does `hasOwnProperty` fix the vulnerability?**
   <details>
   <summary>Answer</summary>
   `hasOwnProperty` checks if a property exists directly on the object, not in its prototype chain. This prevents traversal into `__proto__` or other prototype properties.
   </details>

---

## Lab Exercise

Let's observe the vulnerability in action:

```bash
# Watch the vulnerable container logs
docker logs -f react2shell-vulnerable
```

In another terminal:
```bash
# Send a test payload (safe - just math)
python cli/react2shell.py http://localhost:3011 -v
```

Watch the logs to see the server processing the payload.

---

**Next Chapter:** [Exploitation Techniques →](03-exploitation.md)
